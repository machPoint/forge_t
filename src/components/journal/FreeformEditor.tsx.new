import React, { useState, useRef, useEffect } from "react";
import { useJournal, JournalEntry } from "@/hooks/useJournal";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardHeader, CardContent, CardFooter } from "@/components/ui/card";
import JournalRichEditor from "../JournalRichEditor";
import AIPersonaSelector from "../AIPersonaSelector";
import { Star, Trash2 } from "lucide-react";
import { toast } from "sonner";
import opal from "@/lib/simple-opal-client";
import { getPersonaById } from "@/lib/aiPersonas";
import { getAIFeedback } from "@/lib/openai";
import { getIdentityProfile } from "@/lib/identityProfileService";

interface FreeformEditorProps {
  selectedEntry: JournalEntry;
  updateEntry: (id: string, updates: Partial<JournalEntry>) => void;
  setIsGeneratingFeedback: (isGenerating: boolean) => void;
  addFeedback: (entryId: string, feedback: string) => void;
  activePersonaId: string;
  addEntry: (entry: Partial<JournalEntry>) => void;
  onFeedbackRequest?: () => void;
  deleteEntry?: (id: string) => void;
  toggleStarEntry?: (id: string) => void;
  toggleArchiveEntry?: (id: string) => void;
}

const FreeformEditor: React.FC<FreeformEditorProps> = ({
  selectedEntry,
  updateEntry,
  setIsGeneratingFeedback,
  addFeedback,
  activePersonaId,
  addEntry,
  onFeedbackRequest,
  deleteEntry,
  toggleStarEntry,
  toggleArchiveEntry,
}) => {
  // Initialize with empty strings if selectedEntry properties are undefined
  const [title, setTitle] = useState(selectedEntry?.title || "");
  const [content, setContent] = useState(selectedEntry?.content || "");
  const [isEditing, setIsEditing] = useState(false);
  const [isSummarizing, setIsSummarizing] = useState(false);
  const titleRef = useRef<HTMLInputElement>(null);

  // Auto-focus logic - ensure selectedEntry is defined
  useEffect(() => {
    if (selectedEntry && titleRef.current) {
      setTitle(selectedEntry.title || "");
      setContent(selectedEntry.content || "");
      setIsEditing(false); // Reset editing state when a new entry is selected
    }
  }, [selectedEntry]);

  // Handle content changes - ensure safe updates
  const handleContentChange = (value: string) => {
    setContent(value);
    if (selectedEntry?.id) {
      updateEntry(selectedEntry.id, { content: value });
    }
  };

  // Handle title changes - ensure safe updates
  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTitle = e.target.value;
    setTitle(newTitle);
    if (selectedEntry?.id) {
      updateEntry(selectedEntry.id, { title: newTitle });
    }
  };

  // Save the current entry - ensure safe operations
  const handleSave = () => {
    if (selectedEntry?.id) {
      updateEntry(selectedEntry.id, { 
        title: title || "Untitled Entry", 
        content,
        updatedAt: new Date().toISOString()
      });
      toast.success("Entry saved successfully");
    } else {
      // Create a new entry if none is selected
      addEntry({
        title: title || "Untitled Entry",
        content,
        personaId: activePersonaId
      });
      toast.success("New entry created");
    }
  };

  // Save journal entry to core system, updating if it already exists
  const saveToMemory = async () => {
    if (!content.trim()) {
      toast.error("No content to save");
      return;
    }

    if (!opal.ready()) {
      toast.error("OPAL not connected. Please connect first.");
      return;
    }

    setIsSummarizing(true); // Reusing the state variable for the loading indicator

    try {
      // First check if this journal entry was previously saved to core
      let existingMemoryId = null;
      
      try {
        const allMemories = await opal.callTool('memory_list', {});
        console.log('All memories:', allMemories);
        
        // Look for any memory with matching attributes (client-side filtering)
        if (Array.isArray(allMemories)) {
          const matchingMemory = allMemories.find(memory => 
            memory.source === 'journal' && 
            memory.journal_id === selectedEntry?.id
          );
          
          if (matchingMemory) {
            existingMemoryId = matchingMemory.id;
            console.log(`Found existing memory with ID ${existingMemoryId} for journal entry ${selectedEntry?.id}`);
          }
        }
      } catch (err) {
        console.error('Error checking for existing memory:', err);
        // Continue with creation even if lookup fails
      }

      // Prepare the memory data
      const memoryData = {
        title: title || "Untitled Entry",
        content: content,
        source: "journal",
        journal_id: selectedEntry?.id,
        tags: [], // Auto-tagging happens on the server side
        summary: "", // Auto-summarization happens on the server side
      };

      // Determine if we're updating or creating
      const action = existingMemoryId ? 'memory_update' : 'memory_create';
      
      // Prepare action parameters
      const actionParams = existingMemoryId ? 
        { id: existingMemoryId, ...memoryData } : // For updates, include ID
        memoryData; // For new entries, include all fields

      console.log(`${action} with params:`, actionParams);
      
      // Create or update the memory
      const result = await opal.callTool(action, actionParams);
      console.log(`${action} result:`, result);

      toast.success(
        existingMemoryId ? 
          "Core entry updated successfully" : 
          "Added to Core successfully"
      );
    } catch (error: unknown) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error("Error saving to Core:", error);
      toast.error(`Failed to save to Core: ${errorMsg}`);
    } finally {
      setIsSummarizing(false);
    }
  };

  // Generate AI feedback - now calls OpenAI API
  const generateFeedback = async () => {
    if (!content.trim()) {
      toast.error("No content to analyze");
      return;
    }

    setIsGeneratingFeedback(true);
    
    try {
      // Get the currently selected persona
      const persona = getPersonaById(activePersonaId);
      if (!persona) {
        throw new Error(`Persona with ID ${activePersonaId} not found`);
      }
      
      // Fetch the normalized identity profile
      let identityProfile = null;
      try {
        identityProfile = await getIdentityProfile();
        console.log('[FreeformEditor] Successfully fetched identity profile for AI feedback');
        
        // Log detailed personality profile data to verify real values are present
        const pp = identityProfile?.personality_profile;
        console.log('[FreeformEditor] Personality profile data check:', {
          hasPersonalityData: !!pp,
          bigFive: pp?.big_five || pp?.bigFive,
          attachmentStyle: pp?.attachment_style || pp?.attachmentStyle,
          locusOfControl: pp?.locus_of_control || pp?.locusOfControl,
        });
      } catch (err) {
        console.error('[FreeformEditor] Error fetching identity profile:', err);
        // Continue without identity profile if it fails
      }
      
      // Get feedback from AI
      const feedback = await getAIFeedback({
        content,
        persona,
        identityProfile
      });
      
      console.log('[FreeformEditor] Received AI feedback:', feedback);
      
      // Add feedback to the entry
      if (selectedEntry?.id) {
        addFeedback(selectedEntry.id, feedback);
      }
      
      toast.success("AI feedback generated");
    } catch (error: unknown) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error("Error generating AI feedback:", error);
      toast.error(`Failed to generate feedback: ${errorMsg}`);
    } finally {
      setIsGeneratingFeedback(false);
    }
  };

  return (
    <Card className="h-full flex flex-col shadow-md border-gray-800/5 dark:border-gray-600/5 overflow-hidden">
      <CardHeader className="pb-0">
        <div className="flex justify-between items-center">
          <Input
            ref={titleRef}
            value={title}
            onChange={handleTitleChange}
            placeholder="Entry title..."
            className="text-2xl font-bold border-none shadow-none focus-visible:ring-0 px-0"
          />
          <div className="flex items-center gap-2">
            {selectedEntry?.id && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => toggleStarEntry && toggleStarEntry(selectedEntry.id)}
                  className={`text-gray-400 ${selectedEntry.starred ? 'text-yellow-400 hover:text-yellow-500' : 'hover:text-yellow-400'}`}
                  aria-label={selectedEntry.starred ? 'Unstar' : 'Star'}
                >
                  <Star className="w-4 h-4" fill={selectedEntry.starred ? 'currentColor' : 'none'} />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => toggleArchiveEntry && toggleArchiveEntry(selectedEntry.id)}
                  className="text-gray-400 hover:text-blue-400"
                  aria-label={selectedEntry.archived ? 'Unarchive' : 'Archive'}
                  disabled={selectedEntry.archived}
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="4" rx="1"/><path d="M5 7v11a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7"/><polyline points="9 10 12 13 15 10"/></svg>
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => deleteEntry && deleteEntry(selectedEntry.id)}
                  className="text-gray-400 hover:text-red-400"
                  aria-label="Delete"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </>
            )}
            <AIPersonaSelector />
          </div>
        </div>
      </CardHeader>
      
      <CardContent className="flex-1 overflow-y-auto px-3 pt-3 pb-0 flex flex-col">
        <JournalRichEditor 
          content={content} 
          onChange={handleContentChange} 
          placeholder="Start journaling here..."
          className="flex-1"
        />
      </CardContent>
      
      <CardFooter className="flex justify-between border-t border-gray-200 dark:border-gray-700 pt-4 space-x-2">
        <div className="text-sm text-gray-500 dark:text-gray-400 italic">
          Use the ribbon above for Save and AI Feedback options
        </div>
      </CardFooter>
    </Card>
  );
};

export default FreeformEditor;
